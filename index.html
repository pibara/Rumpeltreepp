<!doctype html>
<html>
  <head>
    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="chrome=1">
    <title>RumpelTree++ by pibara</title>
    <link rel="stylesheet" href="stylesheets/styles.css">
    <link rel="stylesheet" href="stylesheets/pygment_trac.css">
    <script src="https://ajax.googleapis.com/ajax/libs/jquery/1.7.1/jquery.min.js"></script>
    <script src="javascripts/respond.js"></script>
    <!--[if lt IE 9]>
      <script src="//html5shiv.googlecode.com/svn/trunk/html5.js"></script>
    <![endif]-->
    <!--[if lt IE 8]>
    <link rel="stylesheet" href="stylesheets/ie.css">
    <![endif]-->
    <meta name="viewport" content="width=device-width, initial-scale=1, user-scalable=no">

  </head>
  <body>
      <div id="header">
        <nav>
          <li class="fork"><a href="https://github.com/pibara/Rumpeltreepp">View On GitHub</a></li>
          <li class="downloads"><a href="https://github.com/pibara/Rumpeltreepp/tarball/master">TAR</a></li>
          <li class="title">DOWNLOADS</li>
        </nav>
      </div><!-- end header -->

    <div class="wrapper">

      <section>
        <div id="title">
          <h1>RumpelTree++</h1>
          <p>C++ Rumpelstiltskin tree-graph library</p>
          <hr>
          <span class="credits left">Project maintained by <a href="https://github.com/pibara">pibara</a></span>
          <span class="credits right">Hosted on GitHub Pages &mdash; Theme by <a href="https://twitter.com/michigangraham">mattgraham</a></span>
        </div>

        <h3>
<a name="introduction" class="anchor" href="#introduction"><span class="octicon octicon-link"></span></a>Introduction</h3>
<p>
RumpelTree++ is a C++11 implementation of the <A HREF="http://minorfs.wordpress.com/2014/03/21/rumpelstiltskin-and-his-children-part-2/">Rumpelstiltskin Tree-graph sparsecap algorithm</A>. This algorithm allows any decomposable singly-attenuable Directional Acyclic Graph (DAG) structured authority graph to use <A HREF="http://c2.com/cgi/wiki?PasswordCapabilityModel">sparse capabilities</A> as tokens of authority for potentially singly-attenuated sub-graphs.The algorithm imposes storage and encryption keys to be used for the serialisation of DAG nodes. While the RumpelTree++ was written primary for use in the upcomming RumpelstiltskinFS, a sparse friendly encrypted rewrite of one of the core <A HREF="http://www.linuxjournal.com/magazine/minorfs">MinorFS</A> user-space file systems. The prima advantage of this algoritm for RumpelstiltskinFS is that it removes the need of any lookup table like the sqlite database used in the earlier MinorFS solution. The library and the algorithm were both written and designed with RRumpelstiltskinFS in mind, but they should be usable in a much wider range of situations, including as basis for <A HREF="http://www.w3.org/TR/capability-urls/">capability URLs</A>.  
</p>
<h3>
<a name="installation" class="anchor" href="#installation"><span class="octicon octicon-link"></span></a>Installation</h3>

<p>Before installing, please make sure you have <A HREF="http://www.cryptopp.com/">Crypto++</A>, <A HREF="http://cmake.org/">cmake</A> and either a recent version of the <A HREF="https://gcc.gnu.org/">GNU C++ compiler</A> or <A HREF="http://clang.llvm.org/">Clang</A> installed on your system. If you are running Linux, each of these should be available in your standard repository. After having taken care of these prerequisites, do the following:</p>

<pre><code>$ git clone https://github.com/pibara/Rumpeltreepp.git
$ cd Rumpeltreepp
$ mkdir build
$ cd build
$ cmake ..
$ make
$ make test
$ sudo make install
</code></pre>

<p>If any of the steps before 'sudo make install' fails, please contact <a href="https://github.com/pibara">pibara</a>.</p>

<h3>
<a name="peer-review" class="anchor" href="#peer-review"><span class="octicon octicon-link"></span></a>Peer review.</h3>

<p>Currently RumpelTree++ is a one-man project, and while the author has over a decade of experienc with secure coding practices, recent events
like heartblead have shown the importance of peer review of security sensitive code. The <a href="https://github.com/pibara">author</a> of RumpelTree++ 
is currently looking for anyone with knowledge on at least two of the folowing subjects to contribute a peer review to this project:
<ul>
<li>C++11</li>
<li>Capability based security</li>
<li>Crypto</li>
</ul>
RumpelTree++ is likely to become a crucial part of the TCB for a remastered Ubuntu distribution aiming to be 100% trojan-resistant. Given the pivotal role 
RumpelTree++ would play in this system, its of the highest importance that there are no security bugs or crypto fuck-ups in the library. If anyone is willing 
and able to contribute a peer review to this project, your contributions shall be highly appreciated and will benefit the creation of a trojan resistant envinronment 
in a major way.
</p>

<h2>
<a name="header" class="anchor" href="#header"><span class="octicon octicon-link"></span></a>General usage</h2>

<p>
In order to use RumpelTree++ in your code, you should include the Rumpelstiltskin header file to your C++ code.
</p>
<p>
<pre><code>#include &lt;rumpelstiltskin.hpp&gt;
</code></pre>
</p>

<p>
Next to this, you will need to inform your build system about the fact that your application needs to be linked against the rumpeltree++ library. If you are using CMake, this should be done something like:
</p>
<p>
<pre><code>target_link_libraries(yourapp rumpeltree++)
</code></pre>
</p>
<h3>
<a name="strings" class="anchor" href="#strings"><span class="octicon octicon-link"></span></a>Strings</h3>

<p>RumpleTree++ deels with sparse caps. These sparse caps are basically strings that potentialy hold tremendous authority. Given that its best to minimize the risks of holding this authority, RumpelTree++ comes with its own string class rumpelstiltskin::string that should be close to a drop-in replacement for std::string.
The rumpelstiltskin::string class is basically a RAIIish like wrapper for std::string that clears the content of the wrapped string prior to destruction. By doing this, the lifetime of the spare caps in process memory is limited to the logical lifetime of the strings in your program. This while when using std::string for such strings, the spare caps may linger in process memory for quite some time, and may end up in uninitialized memory allocated to other parts of your program, what from a least authority perspective is a bad idea. It is strongly suggested that when your programs handles sparse caps outside of the direct RumpelTree++ context, it use rumpelstiltskin::string to store them.
</p>
<p>
Mostly when using RumpelTree++ you won't have to concern yourself about the difference between rumpelstiltskin::string and std::string. The use of the C++11 auto keyword should hide this from you for the most part, and the interface of rumpelstiltskin::string is sufficiently similar to that of std::string so that you should hardly notice it in &gt;90% of cases.
</p>
<p>
Next to rumpelstiltskin::string, RumpelTree++ also comes with a convenience function for wiping 32 byte long representations of encryption keys (that we shall discuss later). If for some reason you need to copy an encryption key out of a RumpelTree++ object, its suggested you wrap this key inh a RAII object and invoke this convenience function from its destructor.
</p>

<p>
<pre><code>YourClass::~YourClass() {
     rumpelstiltskin::memclear32(mKey);
}
</code></pre>
</p>

<h2>
<a name="usage" class="anchor" href="#usage"><span class="octicon octicon-link"></span></a>Server side usage.</h2>
<p>
The Rumpelstiltskin Tree-graph sparsecap algorithm supports some operations to only be performed on the server side, while other operations may for scalability and performance reasons also be done on the client side. If you are building a server or a file-system you may opt to ignore the whole concept of client side operations, or you may build in facilities that allow a select set of operations to also be performed client side. The following sections describe the RumpelTree++ operations for the server side. 
</p>

<h3>
<a name="secrets" class="anchor" href="#secrets"><span class="octicon octicon-link"></span></a>Secrets</h3>

<p>
The server itself needs one or two secrets:
<ul>
<li>A private secret</li>
<li>An optional cloud secret, possibly shared with its clients.</li>
</ul>
Its important to note that the cloud secret is the secret used to get from an attenuated authority cap to a storage key. 
Giving clients access to the cloud key, together with giving them read-only access to storage-key indexed encrypted serialized node storage,
could allow client side decryption to be implemented, potentially ofloading the server (or file-system) from its decryption tasks and thus 
contributing to better scalability. By default no cloud secret will be used, and read-only access to storage-key indexed encrypted serialized 
node storage would allow anyone with a valid sparse cap decryption access to that node.<br><br>RumpelTree++ offers a convenience function for
creating a secret for use by the server part of the library. 
</p>

<p>
<pre><code>
auto secret=rumpelstiltskin::randomsecret();
</code></pre>
</p>
<p>
This function should only be used at first use of your server or during installation. This secret should be stored in a place where only your server of file-system is able to access it with strict access controll allowing your server and only your server to access it during normal system operations. Whenever the server is restarted, the secret should be retreived from this tightly protected file. We can now create a base server object for our server omplementation to use:
</p>
<p>
<pre><code>
auto server=rumpelstiltskin::create_server(secret);
</code></pre>
</p>
or:
<p>
<pre><code>
auto server=rumpelstiltskin::create_server(secret,cloudsecret);
</code></pre>
</p>
<p>
One of the core concepts of the Rumpelstiltskin Tree-graph sparsecap algorithm is the unattenuated root sparsecap. 
The fun thing is, we can have many roots and in order to create a new root, we can either just make one up, or generate one from a password.
</p>
<p>
<pre><code>
auto randomrootcap=rumpelstiltskin::randomrootcap();
auto personalrootcap=rumpelstiltskin::pass2rootcap("KnockKnockItsMeAg41n"); 
</code></pre>
</p>
<p>
Once we have a root cap or any cap for that matter, we can get to one of the node's of our tree.
</p>
<p>
<pre><code>
auto rootnode=server[personalrootcap];
</code></pre>
</p>
<h3>
<a name="decomposition" class="anchor" href="#decomposition"><span class="octicon octicon-link"></span></a>Decomposition and child nodes.</h3>

<p></p>

<h3>
<a name="attenuation" class="anchor" href="#attenuation"><span class="octicon octicon-link"></span></a>Attenuation.</h3>

<p></p>

<h3>
<a name="storage" class="anchor" href="#storage"><span class="octicon octicon-link"></span></a>Encrypted storage.</h3>

<p></p>

<h2>
<a name="cs-usage" class="anchor" href="#cs-usage"><span class="octicon octicon-link"></span></a>Client side usage.</h3>

<p></p>

<h3>
<a name="cs-attenuation" class="anchor" href="#cs-attenuation"><span class="octicon octicon-link"></span></a>Client side Attenuation.</h3>

<p></p>

      </section>

    </div>
    <!--[if !IE]><script>fixScale(document);</script><![endif]-->
    
  </body>
</html>
